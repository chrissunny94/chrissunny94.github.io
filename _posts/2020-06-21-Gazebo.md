# Gazebo + URDF: Building Physically Accurate Robots for Simulation

In robotics, simulation is not just a visualization tool—it is where **control logic, perception pipelines, and autonomy stacks are validated long before touching real hardware**. Two tools form the backbone of this workflow in ROS-based systems: **URDF** and **Gazebo**.

Together, they allow engineers to define **what a robot is** and **how it behaves in the physical world**.

This post explains how **URDF and Gazebo work together**, why they matter in real systems, and how they are used in practical robotics development.






## What is URDF?

**URDF (Unified Robot Description Format)** is an XML-based format used in ROS to describe a robot’s **structure and kinematics**.

URDF defines:
- Rigid bodies (**links**)
- Motion constraints (**joints**)
- Coordinate frames
- Visual and collision geometry
- Mass and inertia properties

At its core, URDF answers one question:

> *“What is the robot made of, and how are the parts connected?”*

---

## Core URDF Building Blocks

### Links
A **link** represents a rigid body such as:
- Chassis
- Wheels
- Sensor mounts
- LiDAR housing
- Camera frame

Each link can contain:
- **Visual geometry** – meshes used for rendering
- **Collision geometry** – simplified shapes for physics
- **Inertial properties** – mass and inertia tensor

```xml
<link name="base_link">
  <visual>
    <geometry>
      <mesh filename="base.dae"/>
    </geometry>
  </visual>
  <collision>
    <geometry>
      <box size="0.6 0.4 0.2"/>
    </geometry>
  </collision>
  <inertial>
    <mass value="20"/>
    <inertia ixx="1.2" iyy="1.5" izz="2.0"/>
  </inertial>
</link>
````

---

### Joints

**Joints** define how links move relative to each other.

Common joint types:

* `fixed` – no motion (sensor mounts)
* `revolute` – rotation with limits (steering)
* `continuous` – infinite rotation (wheels)
* `prismatic` – linear motion (actuators)

```xml
<joint name="wheel_joint" type="continuous">
  <parent link="base_link"/>
  <child link="wheel_link"/>
  <axis xyz="0 1 0"/>
</joint>
```

---

## Why URDF Alone Is Not Enough

URDF describes **kinematics**, but it does not define:

* Contact dynamics
* Friction
* Gravity response
* Sensor noise
* Actuator behavior

This is where **Gazebo** comes in.

---

## Gazebo: Bringing Physics to Life

**Gazebo** is a 3D physics simulator that integrates tightly with ROS. It takes a URDF model and adds **real-world physics** on top of it.

Gazebo simulates:

* Gravity and collisions
* Friction and damping
* Wheel-ground interaction
* Sensor behavior (LiDAR, camera, IMU)
* Actuator dynamics

In short:

> **URDF defines the robot.
> Gazebo defines how it behaves.**

---

## Extending URDF for Gazebo

Gazebo uses special `<gazebo>` tags to augment URDF with physics properties.

### Collision and Friction

```xml
<gazebo reference="wheel_link">
  <mu1>1.2</mu1>
  <mu2>1.2</mu2>
  <kp>100000</kp>
  <kd>1.0</kd>
</gazebo>
```

This controls:

* Wheel traction
* Slip behavior
* Contact stiffness

Correct friction values are critical for:

* Wheel odometry accuracy
* Controller stability
* Realistic braking behavior

---

### Mass Distribution & Stability

Incorrect inertia values are one of the **most common causes of unstable simulations**.

Symptoms include:

* Robot shaking
* Wheels bouncing
* Exploding models

Best practices:

* Compute inertia from CAD tools when possible
* Use realistic mass values
* Keep center of mass low for mobile robots

---

## Sensors in Gazebo

Gazebo allows sensors to be attached directly to URDF links.

### Example: IMU

```xml
<gazebo reference="imu_link">
  <sensor type="imu" name="imu_sensor">
    <update_rate>200</update_rate>
    <imu>
      <noise>
        <type>gaussian</type>
        <stddev>0.001</stddev>
      </noise>
    </imu>
  </sensor>
</gazebo>
```

This enables:

* IMU data for state estimation
* Sensor fusion testing
* SLAM validation

Similar plugins exist for:

* LiDAR
* Cameras
* GPS
* Depth sensors

---

## URDF, Gazebo, and Control Systems

URDF also defines **transmissions**, which connect joints to controllers.

```xml
<transmission name="wheel_trans">
  <type>transmission_interface/SimpleTransmission</type>
  <joint name="wheel_joint">
    <hardwareInterface>hardware_interface/VelocityJointInterface</hardwareInterface>
  </joint>
</transmission>
```

This enables:

* PID velocity control
* Differential drive controllers
* Ackermann steering models
* Model Predictive Control (MPC) testing

---

## Typical Real-World Workflow

1. **Design robot structure** in URDF/Xacro
2. **Attach collision & inertial models**
3. **Add Gazebo physics parameters**
4. **Integrate sensors**
5. **Connect controllers**
6. **Validate in Gazebo**
7. **Deploy same URDF to real hardware**

A well-built URDF often transitions to hardware with **minimal changes**.

---

## Common Pitfalls

* Overly complex collision meshes
* Incorrect inertia tensors
* Unrealistic friction values
* Misaligned coordinate frames
* Treating simulation as “just visuals”

Simulation is only useful if it is **physically honest**.

---

## Why This Matters

Gazebo + URDF enable:

* Faster iteration
* Safer testing
* Reproducible experiments
* Hardware-agnostic development

For mobile robots, ADAS systems, and autonomous vehicles, **simulation is not optional—it is foundational**.




1. Introduction & Robot Description (URDF)

Learn the basics of robot modeling and setting up your initial file structure.

<iframe width="560" height="315" src="https://www.youtube.com/embed/K8HeF8LAKjI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
2. Building the Links & Joints (Xacro)

Converting raw XML into clean, modular Xacro code.

<iframe width="560" height="315" src="https://www.youtube.com/embed/d6OLjZo52UA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
3. Gazebo Integration & Physics

Bringing the model into the simulator and adding collision/inertial properties.

<iframe width="560" height="315" src="https://www.youtube.com/embed/6k2xlwqBV1I" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
4. Differential Drive & Movement

Using the Gazebo ROS plugin to make the robot move via /cmd_vel.

<iframe width="560" height="315" src="https://www.youtube.com/embed/NeOKHtxKq08" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
5. Adding Sensors (LiDAR)

Simulating a laser scanner to perceive the environment.

<iframe width="560" height="315" src="https://www.youtube.com/embed/-_WT1Vd2T18" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
6. Adding Sensors (Cameras)

Integrating visual data and camera plugins into the simulation.

<iframe width="560" height="315" src="https://www.youtube.com/embed/nX779G6PvZo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>